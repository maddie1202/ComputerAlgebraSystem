//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\madel\source\repos\ComputerAlgebraSystem\ComputerAlgrebraSystem\Grammar\Math.g4 by ANTLR 4.6.6-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace ComputerAlgrebraSystem.Grammar {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class MathParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, OP_ADD=6, OP_SUB=7, OP_MUL=8, 
		OP_DIV=9, OP_POW=10, VAR=11, NUM=12, WS=13;
	public const int
		RULE_compileUnit = 0, RULE_equation = 1, RULE_expression = 2, RULE_functionName = 3, 
		RULE_parenthesesExpression = 4, RULE_multiplicationExpression = 5, RULE_numberExpression = 6, 
		RULE_variableExpression = 7;
	public static readonly string[] ruleNames = {
		"compileUnit", "equation", "expression", "functionName", "parenthesesExpression", 
		"multiplicationExpression", "numberExpression", "variableExpression"
	};

	private static readonly string[] _LiteralNames = {
		null, "'='", "'('", "')'", "'sqrt'", "'exp'", "'+'", "'-'", "'*'", "'/'", 
		"'^'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, "OP_ADD", "OP_SUB", "OP_MUL", "OP_DIV", 
		"OP_POW", "VAR", "NUM", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Math.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public MathParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class CompileUnitContext : ParserRuleContext {
		public CompileUnitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_compileUnit; } }
	 
		public CompileUnitContext() { }
		public virtual void CopyFrom(CompileUnitContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class EquationCompileUnitContext : CompileUnitContext {
		public EquationContext equation() {
			return GetRuleContext<EquationContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(MathParser.Eof, 0); }
		public EquationCompileUnitContext(CompileUnitContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterEquationCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitEquationCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquationCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ExpressionCompileUnitContext : CompileUnitContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(MathParser.Eof, 0); }
		public ExpressionCompileUnitContext(CompileUnitContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterExpressionCompileUnit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitExpressionCompileUnit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionCompileUnit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CompileUnitContext compileUnit() {
		CompileUnitContext _localctx = new CompileUnitContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_compileUnit);
		try {
			State = 22;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				_localctx = new ExpressionCompileUnitContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 16; expression(0);
				State = 17; Match(Eof);
				}
				break;

			case 2:
				_localctx = new EquationCompileUnitContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 19; equation();
				State = 20; Match(Eof);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EquationContext : ParserRuleContext {
		public ExpressionContext left;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public EquationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_equation; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterEquation(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitEquation(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEquation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EquationContext equation() {
		EquationContext _localctx = new EquationContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_equation);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 24; _localctx.left = expression(0);
			State = 25; Match(T__0);
			State = 26; _localctx.right = expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DivisionContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public DivisionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterDivision(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitDivision(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDivision(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesesContext : ExpressionContext {
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public ParenthesesContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterParentheses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitParentheses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParentheses(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberContext : ExpressionContext {
		public NumberExpressionContext numberExpression() {
			return GetRuleContext<NumberExpressionContext>(0);
		}
		public NumberContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class FunctionContext : ExpressionContext {
		public FunctionNameContext func;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FunctionNameContext functionName() {
			return GetRuleContext<FunctionNameContext>(0);
		}
		public FunctionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableContext : ExpressionContext {
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public VariableContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SubtractionContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public SubtractionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterSubtraction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitSubtraction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubtraction(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicationNoAsteriskContext : ExpressionContext {
		public MultiplicationExpressionContext multiplicationExpression() {
			return GetRuleContext<MultiplicationExpressionContext>(0);
		}
		public MultiplicationNoAsteriskContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterMultiplicationNoAsterisk(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitMultiplicationNoAsterisk(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicationNoAsterisk(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class UnaryContext : ExpressionContext {
		public IToken op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public UnaryContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterUnary(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitUnary(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnary(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PowerContext : ExpressionContext {
		public ExpressionContext left;
		public IToken op;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public PowerContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterPower(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitPower(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPower(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicationContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public MultiplicationContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterMultiplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitMultiplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AdditionContext : ExpressionContext {
		public ExpressionContext left;
		public ExpressionContext right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public AdditionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterAddition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitAddition(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddition(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(_ctx, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 4;
		EnterRecursionRule(_localctx, 4, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 40;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
				{
				_localctx = new ParenthesesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 29; parenthesesExpression();
				}
				break;

			case 2:
				{
				_localctx = new FunctionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 30; ((FunctionContext)_localctx).func = functionName();
				State = 31; Match(T__1);
				State = 32; expression(0);
				State = 33; Match(T__2);
				}
				break;

			case 3:
				{
				_localctx = new UnaryContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 35;
				((UnaryContext)_localctx).op = _input.Lt(1);
				_la = _input.La(1);
				if ( !(_la==OP_ADD || _la==OP_SUB) ) {
					((UnaryContext)_localctx).op = _errHandler.RecoverInline(this);
				} else {
					if (_input.La(1) == TokenConstants.Eof) {
						matchedEOF = true;
					}

					_errHandler.ReportMatch(this);
					Consume();
				}
				State = 36; expression(9);
				}
				break;

			case 4:
				{
				_localctx = new MultiplicationNoAsteriskContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 37; multiplicationExpression(0);
				}
				break;

			case 5:
				{
				_localctx = new NumberContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 38; numberExpression();
				}
				break;

			case 6:
				{
				_localctx = new VariableContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 39; variableExpression();
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 59;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,3,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 57;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
					case 1:
						{
						_localctx = new PowerContext(new ExpressionContext(_parentctx, _parentState));
						((PowerContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 42;
						if (!(Precpred(_ctx, 8))) throw new FailedPredicateException(this, "Precpred(_ctx, 8)");
						State = 43; ((PowerContext)_localctx).op = Match(OP_POW);
						State = 44; ((PowerContext)_localctx).right = expression(9);
						}
						break;

					case 2:
						{
						_localctx = new MultiplicationContext(new ExpressionContext(_parentctx, _parentState));
						((MultiplicationContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 45;
						if (!(Precpred(_ctx, 6))) throw new FailedPredicateException(this, "Precpred(_ctx, 6)");
						State = 46; Match(OP_MUL);
						State = 47; ((MultiplicationContext)_localctx).right = expression(7);
						}
						break;

					case 3:
						{
						_localctx = new DivisionContext(new ExpressionContext(_parentctx, _parentState));
						((DivisionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 48;
						if (!(Precpred(_ctx, 5))) throw new FailedPredicateException(this, "Precpred(_ctx, 5)");
						State = 49; Match(OP_DIV);
						State = 50; ((DivisionContext)_localctx).right = expression(6);
						}
						break;

					case 4:
						{
						_localctx = new AdditionContext(new ExpressionContext(_parentctx, _parentState));
						((AdditionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 51;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 52; Match(OP_ADD);
						State = 53; ((AdditionContext)_localctx).right = expression(5);
						}
						break;

					case 5:
						{
						_localctx = new SubtractionContext(new ExpressionContext(_parentctx, _parentState));
						((SubtractionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 54;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 55; Match(OP_SUB);
						State = 56; ((SubtractionContext)_localctx).right = expression(4);
						}
						break;
					}
					} 
				}
				State = 61;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,3,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class FunctionNameContext : ParserRuleContext {
		public FunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterFunctionName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitFunctionName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionNameContext functionName() {
		FunctionNameContext _localctx = new FunctionNameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_functionName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 62;
			_la = _input.La(1);
			if ( !(_la==T__3 || _la==T__4) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesesExpressionContext : ParserRuleContext {
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenthesesExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesesExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterParenthesesExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitParenthesesExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesesExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesesExpressionContext parenthesesExpression() {
		ParenthesesExpressionContext _localctx = new ParenthesesExpressionContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_parenthesesExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 64; Match(T__1);
			State = 65; expression(0);
			State = 66; Match(T__2);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplicationExpressionContext : ParserRuleContext {
		public MultiplicationExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicationExpression; } }
	 
		public MultiplicationExpressionContext() { }
		public virtual void CopyFrom(MultiplicationExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DoubleParenthesesContext : MultiplicationExpressionContext {
		public ParenthesesExpressionContext leftParenExpr;
		public ParenthesesExpressionContext rightParenExpr;
		public ParenthesesExpressionContext[] parenthesesExpression() {
			return GetRuleContexts<ParenthesesExpressionContext>();
		}
		public ParenthesesExpressionContext parenthesesExpression(int i) {
			return GetRuleContext<ParenthesesExpressionContext>(i);
		}
		public DoubleParenthesesContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterDoubleParentheses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitDoubleParentheses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDoubleParentheses(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableNumberContext : MultiplicationExpressionContext {
		public VariableExpressionContext leftVar;
		public NumberExpressionContext rightNum;
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public NumberExpressionContext numberExpression() {
			return GetRuleContext<NumberExpressionContext>(0);
		}
		public VariableNumberContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariableNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariableNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberVariableContext : MultiplicationExpressionContext {
		public NumberExpressionContext leftNum;
		public VariableExpressionContext rightVar;
		public NumberExpressionContext numberExpression() {
			return GetRuleContext<NumberExpressionContext>(0);
		}
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public NumberVariableContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterNumberVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitNumberVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberVariable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicationParenthesesContext : MultiplicationExpressionContext {
		public MultiplicationExpressionContext leftMulExpr;
		public ParenthesesExpressionContext rightParenExpr;
		public MultiplicationExpressionContext multiplicationExpression() {
			return GetRuleContext<MultiplicationExpressionContext>(0);
		}
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public MultiplicationParenthesesContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterMultiplicationParentheses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitMultiplicationParentheses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicationParentheses(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesesMultiplicationContext : MultiplicationExpressionContext {
		public ParenthesesExpressionContext rightParenExpr;
		public MultiplicationExpressionContext leftMulExpr;
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public MultiplicationExpressionContext multiplicationExpression() {
			return GetRuleContext<MultiplicationExpressionContext>(0);
		}
		public ParenthesesMultiplicationContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterParenthesesMultiplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitParenthesesMultiplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesesMultiplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableParenthesesContext : MultiplicationExpressionContext {
		public VariableExpressionContext leftVar;
		public ParenthesesExpressionContext rightParenExpr;
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public VariableParenthesesContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariableParentheses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariableParentheses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableParentheses(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class MultiplicationVariableContext : MultiplicationExpressionContext {
		public MultiplicationExpressionContext leftMulExpr;
		public VariableExpressionContext rightVar;
		public MultiplicationExpressionContext multiplicationExpression() {
			return GetRuleContext<MultiplicationExpressionContext>(0);
		}
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public MultiplicationVariableContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterMultiplicationVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitMultiplicationVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicationVariable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesesNumberContext : MultiplicationExpressionContext {
		public ParenthesesExpressionContext leftParenExpr;
		public NumberExpressionContext rightNum;
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public NumberExpressionContext numberExpression() {
			return GetRuleContext<NumberExpressionContext>(0);
		}
		public ParenthesesNumberContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterParenthesesNumber(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitParenthesesNumber(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesesNumber(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesesVariableContext : MultiplicationExpressionContext {
		public ParenthesesExpressionContext leftParenExpr;
		public VariableExpressionContext rightVar;
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public ParenthesesVariableContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterParenthesesVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitParenthesesVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesesVariable(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableMultiplicationContext : MultiplicationExpressionContext {
		public VariableExpressionContext rightVar;
		public MultiplicationExpressionContext leftMulExpr;
		public VariableExpressionContext variableExpression() {
			return GetRuleContext<VariableExpressionContext>(0);
		}
		public MultiplicationExpressionContext multiplicationExpression() {
			return GetRuleContext<MultiplicationExpressionContext>(0);
		}
		public VariableMultiplicationContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariableMultiplication(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariableMultiplication(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableMultiplication(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NumberParenthesesContext : MultiplicationExpressionContext {
		public NumberExpressionContext leftNum;
		public ParenthesesExpressionContext rightParenExpr;
		public NumberExpressionContext numberExpression() {
			return GetRuleContext<NumberExpressionContext>(0);
		}
		public ParenthesesExpressionContext parenthesesExpression() {
			return GetRuleContext<ParenthesesExpressionContext>(0);
		}
		public NumberParenthesesContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterNumberParentheses(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitNumberParentheses(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberParentheses(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class VariableVariableContext : MultiplicationExpressionContext {
		public VariableExpressionContext leftVar;
		public VariableExpressionContext rightVar;
		public VariableExpressionContext[] variableExpression() {
			return GetRuleContexts<VariableExpressionContext>();
		}
		public VariableExpressionContext variableExpression(int i) {
			return GetRuleContext<VariableExpressionContext>(i);
		}
		public VariableVariableContext(MultiplicationExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariableVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariableVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicationExpressionContext multiplicationExpression() {
		return multiplicationExpression(0);
	}

	private MultiplicationExpressionContext multiplicationExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		MultiplicationExpressionContext _localctx = new MultiplicationExpressionContext(_ctx, _parentState);
		MultiplicationExpressionContext _prevctx = _localctx;
		int _startState = 10;
		EnterRecursionRule(_localctx, 10, RULE_multiplicationExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 99;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				{
				_localctx = new DoubleParenthesesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 69; ((DoubleParenthesesContext)_localctx).leftParenExpr = parenthesesExpression();
				State = 70; ((DoubleParenthesesContext)_localctx).rightParenExpr = parenthesesExpression();
				}
				break;

			case 2:
				{
				_localctx = new NumberVariableContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 72; ((NumberVariableContext)_localctx).leftNum = numberExpression();
				State = 73; ((NumberVariableContext)_localctx).rightVar = variableExpression();
				}
				break;

			case 3:
				{
				_localctx = new VariableVariableContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 75; ((VariableVariableContext)_localctx).leftVar = variableExpression();
				State = 76; ((VariableVariableContext)_localctx).rightVar = variableExpression();
				}
				break;

			case 4:
				{
				_localctx = new VariableNumberContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 78; ((VariableNumberContext)_localctx).leftVar = variableExpression();
				State = 79; ((VariableNumberContext)_localctx).rightNum = numberExpression();
				}
				break;

			case 5:
				{
				_localctx = new NumberParenthesesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 81; ((NumberParenthesesContext)_localctx).leftNum = numberExpression();
				State = 82; ((NumberParenthesesContext)_localctx).rightParenExpr = parenthesesExpression();
				}
				break;

			case 6:
				{
				_localctx = new VariableParenthesesContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 84; ((VariableParenthesesContext)_localctx).leftVar = variableExpression();
				State = 85; ((VariableParenthesesContext)_localctx).rightParenExpr = parenthesesExpression();
				}
				break;

			case 7:
				{
				_localctx = new ParenthesesNumberContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 87; ((ParenthesesNumberContext)_localctx).leftParenExpr = parenthesesExpression();
				State = 88; ((ParenthesesNumberContext)_localctx).rightNum = numberExpression();
				}
				break;

			case 8:
				{
				_localctx = new ParenthesesVariableContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 90; ((ParenthesesVariableContext)_localctx).leftParenExpr = parenthesesExpression();
				State = 91; ((ParenthesesVariableContext)_localctx).rightVar = variableExpression();
				}
				break;

			case 9:
				{
				_localctx = new ParenthesesMultiplicationContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 93; ((ParenthesesMultiplicationContext)_localctx).rightParenExpr = parenthesesExpression();
				State = 94; ((ParenthesesMultiplicationContext)_localctx).leftMulExpr = multiplicationExpression(3);
				}
				break;

			case 10:
				{
				_localctx = new VariableMultiplicationContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 96; ((VariableMultiplicationContext)_localctx).rightVar = variableExpression();
				State = 97; ((VariableMultiplicationContext)_localctx).leftMulExpr = multiplicationExpression(2);
				}
				break;
			}
			_ctx.stop = _input.Lt(-1);
			State = 107;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 105;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
					case 1:
						{
						_localctx = new MultiplicationParenthesesContext(new MultiplicationExpressionContext(_parentctx, _parentState));
						((MultiplicationParenthesesContext)_localctx).leftMulExpr = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicationExpression);
						State = 101;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 102; ((MultiplicationParenthesesContext)_localctx).rightParenExpr = parenthesesExpression();
						}
						break;

					case 2:
						{
						_localctx = new MultiplicationVariableContext(new MultiplicationExpressionContext(_parentctx, _parentState));
						((MultiplicationVariableContext)_localctx).leftMulExpr = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_multiplicationExpression);
						State = 103;
						if (!(Precpred(_ctx, 1))) throw new FailedPredicateException(this, "Precpred(_ctx, 1)");
						State = 104; ((MultiplicationVariableContext)_localctx).rightVar = variableExpression();
						}
						break;
					}
					} 
				}
				State = 109;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class NumberExpressionContext : ParserRuleContext {
		public IToken value;
		public ITerminalNode NUM() { return GetToken(MathParser.NUM, 0); }
		public NumberExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterNumberExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitNumberExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberExpressionContext numberExpression() {
		NumberExpressionContext _localctx = new NumberExpressionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_numberExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 110; _localctx.value = Match(NUM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableExpressionContext : ParserRuleContext {
		public IToken value;
		public ITerminalNode VAR() { return GetToken(MathParser.VAR, 0); }
		public VariableExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.EnterVariableExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IMathListener typedListener = listener as IMathListener;
			if (typedListener != null) typedListener.ExitVariableExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IMathVisitor<TResult> typedVisitor = visitor as IMathVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableExpressionContext variableExpression() {
		VariableExpressionContext _localctx = new VariableExpressionContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_variableExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112; _localctx.value = Match(VAR);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 2: return expression_sempred((ExpressionContext)_localctx, predIndex);

		case 5: return multiplicationExpression_sempred((MultiplicationExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 8);

		case 1: return Precpred(_ctx, 6);

		case 2: return Precpred(_ctx, 5);

		case 3: return Precpred(_ctx, 4);

		case 4: return Precpred(_ctx, 3);
		}
		return true;
	}
	private bool multiplicationExpression_sempred(MultiplicationExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 5: return Precpred(_ctx, 4);

		case 6: return Precpred(_ctx, 1);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\xFu\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2\x19\n\x2\x3\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x5\x4+\n\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\a\x4<\n\x4\f\x4\xE\x4?\v\x4"+
		"\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3"+
		"\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3"+
		"\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x66\n\a\x3\a"+
		"\x3\a\x3\a\x3\a\a\al\n\a\f\a\xE\ao\v\a\x3\b\x3\b\x3\t\x3\t\x3\t\x2\x2"+
		"\x4\x6\f\n\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x2\x4\x3\x2\b"+
		"\t\x3\x2\x6\a\x82\x2\x18\x3\x2\x2\x2\x4\x1A\x3\x2\x2\x2\x6*\x3\x2\x2\x2"+
		"\b@\x3\x2\x2\x2\n\x42\x3\x2\x2\x2\f\x65\x3\x2\x2\x2\xEp\x3\x2\x2\x2\x10"+
		"r\x3\x2\x2\x2\x12\x13\x5\x6\x4\x2\x13\x14\a\x2\x2\x3\x14\x19\x3\x2\x2"+
		"\x2\x15\x16\x5\x4\x3\x2\x16\x17\a\x2\x2\x3\x17\x19\x3\x2\x2\x2\x18\x12"+
		"\x3\x2\x2\x2\x18\x15\x3\x2\x2\x2\x19\x3\x3\x2\x2\x2\x1A\x1B\x5\x6\x4\x2"+
		"\x1B\x1C\a\x3\x2\x2\x1C\x1D\x5\x6\x4\x2\x1D\x5\x3\x2\x2\x2\x1E\x1F\b\x4"+
		"\x1\x2\x1F+\x5\n\x6\x2 !\x5\b\x5\x2!\"\a\x4\x2\x2\"#\x5\x6\x4\x2#$\a\x5"+
		"\x2\x2$+\x3\x2\x2\x2%&\t\x2\x2\x2&+\x5\x6\x4\v\'+\x5\f\a\x2(+\x5\xE\b"+
		"\x2)+\x5\x10\t\x2*\x1E\x3\x2\x2\x2* \x3\x2\x2\x2*%\x3\x2\x2\x2*\'\x3\x2"+
		"\x2\x2*(\x3\x2\x2\x2*)\x3\x2\x2\x2+=\x3\x2\x2\x2,-\f\n\x2\x2-.\a\f\x2"+
		"\x2.<\x5\x6\x4\v/\x30\f\b\x2\x2\x30\x31\a\n\x2\x2\x31<\x5\x6\x4\t\x32"+
		"\x33\f\a\x2\x2\x33\x34\a\v\x2\x2\x34<\x5\x6\x4\b\x35\x36\f\x6\x2\x2\x36"+
		"\x37\a\b\x2\x2\x37<\x5\x6\x4\a\x38\x39\f\x5\x2\x2\x39:\a\t\x2\x2:<\x5"+
		"\x6\x4\x6;,\x3\x2\x2\x2;/\x3\x2\x2\x2;\x32\x3\x2\x2\x2;\x35\x3\x2\x2\x2"+
		";\x38\x3\x2\x2\x2<?\x3\x2\x2\x2=;\x3\x2\x2\x2=>\x3\x2\x2\x2>\a\x3\x2\x2"+
		"\x2?=\x3\x2\x2\x2@\x41\t\x3\x2\x2\x41\t\x3\x2\x2\x2\x42\x43\a\x4\x2\x2"+
		"\x43\x44\x5\x6\x4\x2\x44\x45\a\x5\x2\x2\x45\v\x3\x2\x2\x2\x46G\b\a\x1"+
		"\x2GH\x5\n\x6\x2HI\x5\n\x6\x2I\x66\x3\x2\x2\x2JK\x5\xE\b\x2KL\x5\x10\t"+
		"\x2L\x66\x3\x2\x2\x2MN\x5\x10\t\x2NO\x5\x10\t\x2O\x66\x3\x2\x2\x2PQ\x5"+
		"\x10\t\x2QR\x5\xE\b\x2R\x66\x3\x2\x2\x2ST\x5\xE\b\x2TU\x5\n\x6\x2U\x66"+
		"\x3\x2\x2\x2VW\x5\x10\t\x2WX\x5\n\x6\x2X\x66\x3\x2\x2\x2YZ\x5\n\x6\x2"+
		"Z[\x5\xE\b\x2[\x66\x3\x2\x2\x2\\]\x5\n\x6\x2]^\x5\x10\t\x2^\x66\x3\x2"+
		"\x2\x2_`\x5\n\x6\x2`\x61\x5\f\a\x5\x61\x66\x3\x2\x2\x2\x62\x63\x5\x10"+
		"\t\x2\x63\x64\x5\f\a\x4\x64\x66\x3\x2\x2\x2\x65\x46\x3\x2\x2\x2\x65J\x3"+
		"\x2\x2\x2\x65M\x3\x2\x2\x2\x65P\x3\x2\x2\x2\x65S\x3\x2\x2\x2\x65V\x3\x2"+
		"\x2\x2\x65Y\x3\x2\x2\x2\x65\\\x3\x2\x2\x2\x65_\x3\x2\x2\x2\x65\x62\x3"+
		"\x2\x2\x2\x66m\x3\x2\x2\x2gh\f\x6\x2\x2hl\x5\n\x6\x2ij\f\x3\x2\x2jl\x5"+
		"\x10\t\x2kg\x3\x2\x2\x2ki\x3\x2\x2\x2lo\x3\x2\x2\x2mk\x3\x2\x2\x2mn\x3"+
		"\x2\x2\x2n\r\x3\x2\x2\x2om\x3\x2\x2\x2pq\a\xE\x2\x2q\xF\x3\x2\x2\x2rs"+
		"\a\r\x2\x2s\x11\x3\x2\x2\x2\t\x18*;=\x65km";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace ComputerAlgrebraSystem.Grammar
